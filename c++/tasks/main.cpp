#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

void inverse();

void rotate(int a[], unsigned size, int shift);
unsigned strlen(const char *str);
void strcat(char *to, const char *from);
int strstr(const char *text, const char *pattern);

int main()
{
    //Напишите программу для решения квадратных уравнений вида a x^2 + b x + c = 0(относительно x). На вход программа получает три целых числа: a , b и c,
    //соответственно. При этом гарантируется, что a != 0. На вывод программа должна вывести два вещественных корня уравнения, разделённые пробелом.
    //Если вещественных корней нет, то программа должна вывести строку "No real roots". Если у уравнения имеется только один корень (кратный корень),
    // то программа должна вывести его дважды. Порядок вывода корней не важен. Ничего, кроме этого, выводить не нужно. Для вычислений с плавающей
    //точкой используйте тип double. При выполнении задания вам может оказаться полезной функция sqrt из заголовочного файла cmath. Замечание: после того,
    // как вы сдадите это задание, попробуйте подумать, как изменилась бы ваша программа, если бы мы не гарантировали, что a != 0.
    /*double coef1 = 0, coef2 = 0, coef3 = 0;
    double discriminant = 0, answer1 = 0, answer2 = 0;
    cin >> coef1 >> coef2 >> coef3;
    discriminant = pow(coef2, 2) - 4 * coef1 * coef3;
    //cout << "discriminant = " << discriminant << endl;
    cout << fixed << setprecision(6);
    if(discriminant > 0)
    {
        answer1 = (- coef2 - sqrt(discriminant)) / (2 * coef1);
        answer2 = (- coef2 + sqrt(discriminant)) / (2 * coef1);
        if(answer1 > answer2)
        {
            double temp = answer1;
            answer1 = answer2;
            answer2 = temp;
        }
        cout << answer1 << " " << answer2;
    }
    else if(discriminant == 0)
    {
        answer1 = (- coef2 ) / (2 * coef1);
        cout << answer1 << " " << answer1;
    }
    else cout << "No real roots";*/


    //Напишите программу, которая посимвольно читает из std::cin, пока не достигнет конца потока ввода, и заменяет несколько подряд
    //идущих пробелов одним и выводит полученный результат в std::cout. Никаких других символов, кроме пробелов удалять не нужно. При
    //выполнении задания вам не разрешается пользоваться дополнительной памятью, а именно: массивами, стандартными контейнерами и строками,
    //даже если вы уже с ними знакомы. Вы можете определять любые вспомогательные функции, если они вам нужны. Подсказка: прочтите внимательно
    //степ про посимвольный ввод. Нулевой символ ('\0'), символ новой строки ('\n') и конец потока — это три разные вещи. Про то, как отловить
    //конец потока —  написано в степе про посимвольный ввод.
    /*char c = '\0';
    char space = ' ', previous = '\0';
    while (cin.get(c))
    {
        if(c == space && previous == space) continue;
        else
        {
            cout << c;
            previous = c;
        }

    }*/


    //Напишите программу для вычисления целочисленного логарифма по основанию 2. На вход программе в первой строке подается число T, далее следует
    //T строк с тестами. Каждый тест состоит из одного целого положительного числа a_i < 10^{9}, для каждого a_i нужно вывести на отдельной строке
    //такое наибольшее число p, что 2^p <= a_i. Гарантируется, что a_i > 1. При решении задачи вы можете определять любые вспомогательные функции,
    //если они вам нужны, более того рекомендуется вынести вычисление логарифма в отдельную функцию.
    //Ограничения: библиотеку cmath (и math.h) использовать запрещено.
    /*uint32_t count = 0,number = 0, iter = 0, tmp = 1;
    cin >> count;
    while(count--)
    {
        cin >> number;
        iter = 0;
        tmp = 1;
        if(number == 1) cout << 0;
        else {
            while(tmp <= number)
            {
                tmp <<= 1;
                //cout << "tmp = " << tmp << " iter = " << iter;
                iter++;
            }
            cout << iter - 1 << " ";
        }


    }*/

    //Вам требуется написать программу, которая "переворачивает" последовательность положительных целых чисел. На вход подается
    //последовательность разделенных пробелами положительных целых чисел. Последовательность заканчивается нулем. Требуется вывести эту
    //последовательность в обратном порядке. На выводе числа нужно так же разделить пробелами. Завершающий ноль — это просто индикатор конца
    //последовательности, он не является ее частью, т.е. выводить его не нужно. Требования к реализации: в данном задании запрещено использовать
    //циклы, а также дополнительную память: массивы, строки или контейнеры (даже, если вы с ними уже знакомы). Вам разрешено заводить вспомогательные
    //функции, если они вам нужны. Подсказка: используйте рекурсию.
    //inverse();


    //В этой задаче вам нужно реализовать функцию, которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).
    //На вход функция принимает массив, его размер и величину сдвига. Например, если на вход функции подан массив: int a[] = { 1, 2, 3, 4, 5 };
    // и требуется циклически сдвинуть его влево на 2 позиции, то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.
    //Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.
    /*int32_t shiftCount = 0;
    uint32_t masSize = 0;
    cin >> masSize >> shiftCount;
    int32_t massive[masSize] = {0};
    for(uint32_t temp = 0; temp < masSize; ++temp)
    {
        massive[temp] = temp + 1;
    }
    rotate(massive, masSize, shiftCount);
    for(uint32_t temp = 0; temp < masSize; ++temp)
    {
        cout << massive[temp] << " ";
    }*/

    //Очень часто для работы со строками нам нужно сначала вычислить длину строки. Для C-style строк длина нигде явно не хранится, но её можно
    //вычислить. Напишите функцию, которая вычисляет длину C-style строки. Учтите, что завершающий нулевой символ считать не нужно.Требования к
    //реализации: при выполнении этого задания вы можете создавать любые вспомогательные функции. Вводить или выводить что-либо не нужно.
    //Реализовывать функцию main не нужно.
    /*const char word[] = "hello";
    cout << strlen(word);*/


    //Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк. Функция конкатенации принимает на вход две C-style строки и
    //дописывает вторую в конец первой так, чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.
    //Не забудьте, что в результирующей строке должен быть только один нулевой символ — тот, что является маркером конца строки.Гарантируется, что в
    //первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины), чтобы разместить конкатенацию обеих строк, но не больше.
    /*char first[256] = "hi,oopooioioiopopo!";
    const char second[26] = "how are you?mami!";
    strcat(first, second);
    for(unsigned temp = 0; temp < strlen(first); ++temp)
    {
        cout << first[temp];
    }*/


    //Напишите функцию поиска первого вхождения шаблона в текст. В качестве первого параметра функция принимает текст (C-style строка), в которой
    //нужно искать шаблон. В качестве второго параметра строку-шаблон (C-style строка), которую нужно найти. Функция возвращает позицию первого
    //вхождения строки-шаблона, если он присутствует в строке (помните, что в C++ принято считать с 0), и -1, если шаблона в тексте нет.
    //Учтите, что пустой шаблон (строка длины 0) можно найти в любом месте текста.
    const char first[20] = "my name", second[20] = " ";
    cout << strstr(first, second);





    return 0;
}

int strstr(const char *text, const char *pattern)
{
    if(!strlen(pattern)) return 0;
    bool patternIsFound = false;
    for(unsigned temp = 0; temp < strlen(text); ++temp)
    {
        if(text[temp] == pattern[0])
        {
            for(unsigned temp1 = 0; temp1 < strlen(pattern); ++ temp1)
            {
                if(text[temp + temp1] != pattern[temp1])
                {
                    break;
                }
                else if(text[temp + temp1] == pattern[temp1] && temp1 == strlen(pattern) - 1) patternIsFound = true;
            }
        }
        if(patternIsFound) return temp;
    }
    return -1;
}

void strcat(char *to, const char *from)
{
    int counter = 0;
    while(to[counter] != '\0')
    {
        //cout << counter << " ";
        ++counter;
    }
    //cout << "counter = " << counter << " ";
    for(unsigned temp = 0; temp <= strlen(from); ++temp)
    {
        to[counter] = from[temp];
        //cout << from[temp];
        ++counter;
    }
}

unsigned strlen(const char *str)
{
    unsigned cnt = 0;
    while(*str++ != '\0')
    {
        ++cnt;
        //str++;
    }
    return cnt;
}

/*void rotate(int a[], unsigned size, int shift)
{
    shift %= size;
    while(shift--)
    {
        int32_t temp = a[0];
        for(uint32_t temp1 = 0; temp1 < size; ++temp1)
        {
            a[temp1] = a[temp1 + 1];
        }
        a[size - 1] = temp;
    }
}*/

/*void inverse()
{
    uint32_t number;
    cin >> number;
    cout << "number in = " << number << endl;
    if(!number)
    {
        return;
    }
    inverse();
    cout << number << " ";
}*/
